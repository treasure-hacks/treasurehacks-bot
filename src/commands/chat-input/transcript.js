// eslint-disable-next-line no-unused-vars
const { Client, ChatInputCommandInteraction, SlashCommandBuilder, PermissionFlagsBits, AttachmentBuilder } = require('discord.js')
const discordTranscripts = require('discord-html-transcripts')
const { JSDOM } = require('jsdom')
const md5 = str => require('crypto').createHash('md5').update(str).digest('hex')
const JSZip = require('jszip')
const chunks = require('buffer-chunks')

/**
 * Initiates a transcript download and posts a status message in the interaction channel
 * @param {ChatInputCommandInteraction} interaction The chat input command interaction
 * @returns {Promise<AttachmentBuilder>} A promise that resolves to the transcript
 */
async function initiateTranscript (interaction) {
  const embeds = [{
    color: 0x0092cc,
    description: '⏳ Creating Transcript',
    footer: { text: 'File will be posted to this channel once finished' }
  }]

  await interaction.guild.members.fetch({ force: true }) // Refresh Members
  const transcriptOptions = { hydrate: true, footerText: 'Exported {number} message{s}', poweredBy: false }
  const transcriptSt = discordTranscripts.createTranscript(interaction.channel, transcriptOptions)

  await interaction.reply({ embeds }) // after initiation so this reply does not get included
  return transcriptSt
}

/**
 * Returns the document associated with the transcript
 * @param {AttachmentBuilder} transcript The attachment generated by the transcript
 * @returns {Document} The HTML transcript document
 */
function documentFromTranscript (transcript) {
  const html = new TextDecoder().decode(transcript.attachment)
  return new JSDOM(html).window.document
}

/**
 * Applies style patches to the document
 * @param {Document} document The HTML document of the transcript
 */
function applyStylePatches (document) {
  // Root border and padding
  const root = document.querySelector('discord-messages')
  root.style = 'padding-block: 2px 4px; border-width: 0;'

  // Footer content
  const footer = document.querySelector('discord-messages > :last-child')
  footer.innerHTML += process.env.EXPORT_FOOTER_CONTENT

  // Retina resolution for profile pictures and server icon
  document.querySelectorAll('.discord-author-avatar img').forEach(img => {
    img.src = img.src.replace('?size=64', '?size=240')
  })
  const headerIcon = document.querySelector('.discord-header-icon img')
  if (headerIcon) headerIcon.src = headerIcon.src.replace('?size=128', '?size=512')
}

/**
 * Downloads attachments (in parallel) from the transcript file and adds them to a zip file
 * @param {Document} document The transcript document
 * @param {JSZip} zip The ZIP file to add the attachments to
 */
async function bundleAttachments (document, zip) {
  const htmlEscape = str => str.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
  const dsAttachments = [...document.querySelectorAll('discord-attachment')]
  await Promise.all(dsAttachments.map(async da => {
    const url = da.getAttribute('url')
    const ext = url.match(/\.([^.]+)\?/)?.at(1) || ''
    const name = `${md5(url)}.${ext}`

    da.setAttribute('url', name)
    da.querySelectorAll(`[src="${htmlEscape(url)}"]`).forEach(el => { el.src = name })
    da.querySelectorAll(`[href="${htmlEscape(url)}"]`).forEach(el => { el.href = name })

    const file = await fetch(url).then(x => x.arrayBuffer()).catch(() => {})
    zip.file(name, file)
  }))
}

/**
 * Builds an info object about the current channel
 * @param {ChatInputCommandInteraction} interaction The chat input command interaction
 * @returns {Promise<{ category: string; date: string | null; }>} Info about the transcript
 */
async function buildInfo (interaction) {
  const info = { category: 'Other', date: null }
  const [message] = await interaction.channel.messages.fetch({ limit: 1 }).catch(() => [])
  if (message) info.date = new Date(message[1].createdTimestamp).toISOString()

  if (interaction.channel.parentId) {
    const category = await interaction.guild.channels.fetch(interaction.channel.parentId)
    info.category = category.name
  }

  return info
}

/**
 * Create the base files and generate the buffer for the ZIP file
 * @param {JSZip} zip The ZIP file used to store the transcript
 * @param {ChatInputCommandInteraction} interaction The chat input command interaction
 * @param {Document} document The transcript's HTML document
 * @param {Promise<{ category: string; date: string | null; }>} info Info about the transcript
 */
async function finalizeZipFile (zip, interaction, document, info) {
  zip.file(`transcript__${interaction.channel.name}.html`, document.documentElement.outerHTML)
  zip.file('info.json', JSON.stringify(await info))
  return await zip.generateAsync({ type: 'nodebuffer' })
}

/**
 * Sends the finalized ZIP file to the user
 * @param {AttachmentBuilder} transcript The default discord attachment generated from the transcript
 * @param {Buffer} zipFile The ZIP file buffer to send
 * @param {ChatInputCommandInteraction} interaction The chat input command interaction
 */
function sendTranscript (transcript, zipFile, interaction) {
  const zipChunks = chunks(zipFile, 25 * 1024 ** 2) // 25 MB
  const dlName = transcript.name.replace('.html', '.zip')
  if (zipChunks.length === 1) {
    Object.assign(transcript, { attachment: zipFile, name: dlName })
    interaction.channel.send({ content: 'Your transcript is ready to download', files: [transcript] })
  } else {
    const files = zipChunks.map((buf, i) => new AttachmentBuilder(buf, { name: `${dlName}_part${i + 1}.dat` }))
    const content = 'Your transcript is ready to download. Once downloaded, you will need ' +
    'to combine these files by running the following command in the same directory as the ' +
    'downloaded files:\n```bash\n' + `cat ${dlName}_part*.dat > ${dlName}` + '\n```'
    interaction.channel.send({ content, files })
  }
}

/**
 * Handles the slash command interaction
 * @param {ChatInputCommandInteraction} interaction The chat input command interaction
 * @param {Client} client The discord bot client
 */
async function createTranscript (interaction, client) {
  const info = buildInfo(interaction) // don't await the promise, so that we can run in parallel
  const transcript = await initiateTranscript(interaction)

  /** @todo figure out how to programmatically test this stuff */
  const document = documentFromTranscript(transcript)
  const zip = new JSZip()

  applyStylePatches(document)
  await bundleAttachments(document, zip)
  const dl = await finalizeZipFile(zip, interaction, document, info)

  sendTranscript(transcript, dl, interaction)
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName('transcript')
    .setDescription('Creates an HTML transcript of the current channel')
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),
  execute: async (interaction, client) => {
    return createTranscript(interaction, client)
  }
}
